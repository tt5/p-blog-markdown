# inf

A language is, the set of sequences of terminal symbols which,
starting with the start symbol, can be generated by repeated
application of syntactic equations, that is, substitutions.

- terminal symbols / vocabulary
- nonterminal symbols (syntactic classes), can be substituted
- syntactic equations / productions. These define the possible
  substitutions of nonterminal symbols. An equation is specified for
  each nonterminal symbol.
- start symbol

# Data Structure

A structure providing efficient access to nodes of a tree near a distinguished location
is called a finger

## Properties

+    fixed size nodes

## vector hosted lists

Erasing an element from the middle of a vector results in all
the other elements after that being moved down, to close the 'hole'.
And that means that (whether we use element indices or pointers as
element references), references to elements after an erased element will be
invalidated (or at least need to be adjusted) after each element deletion.

The `_nextIndex` values needing to be encoded include positive integers (0 included),
specifying the next free entry, and (another) special case value of
-1, which in this case means 'no more free list entries' (so
the equivalent of a null pointer).

`[1,9,3,4,3]`,
`-1` = "invalid value".

$\fbox{1}$  
$\fbox{9}$  
`-9`* (=6)  
$\fbox{3}$  
$\fbox{4}$  
`-2` (=-1) (= end of freelist)  
`-8` (=5)  
$\fbox{3}$  

*: `_numberDead: 3`, `_firstDead: 2`

In order to iterate through this sequence, we'll need to check for
and skip dead entries as we go.

## Producer-Consumer Queues 

Depending on allowed number of producer and consumer threads:  
- Multi-producer/multi-consumer queues (MPMC)  
- Single-producer/multi-consumer queues (SPMC)  
- Multi-producer/single-consumer queues (MPSC)  
- Single-producer/single-consumer queues (SPSC)  

Depending on underlying data structure:  
- Array-based  
- Linked-list-based  
- Hybrid  

For linked-list based queues depending on intrusiveness:  
- Intrusive  
- Non-intrusive  

For linked-list based queues depending on maximum size:  
- Bounded  
- Unbounded  

For bounded queues depending on overflow behavior:  
- Fails on overflow  
- Overwrites the oldest item on overflow  

Depending on requirements for Garbage Collection (object life-time management):  
- Requires GC  
- Does not requires GC   

Depending on support for priorities:  
- with support for message priorities  
- without support for message priorities  

Depending on ordering guarantees:  
- provides causal FIFO/LIFO (strongest)  
- provides per-producer FIFO/LIFO  
- provides best-effort FIFO/LIFO (weakest)  
- no ordering guarantees  

Depending on forward progress guarantees for producers:  
- Waitfree producers  
- Lockfree producers  
- Blocking producers  

Depending on forward progress guarantees for consumers:  
- Waitfree consumers  
- Lockfree consumers  
- Blocking consumers  

Depending on expected usage:  
- A queue usually contains very few or zero messages  
- A queue usually contains substantial amount of messages  

There is also an aspect related to behavior on failure:  
- When a queue is empty/full consumers/producers get blocked  
- When a queue is empty/full consumers/producers instantly get 'false'  

Concurrent programming in general, but lock-free in
particular, requires thinking in terms of transactions

compare-and-swap (CAS).
It compares the contents of a memory location to a given value
and, only if they are the same, modifies the contents of that
memory location to a given new value. This is done as a single atomic operation.

# Complexity

Hierarchy:  
all languages  
enumerable  
decidable  
NP  
P  
context-free (pushdown automata)  
regular  

```
P := {A : the language A is decidable in polynomial time}

FP := {F : the function F is computable in polynomial time}.
```

Boolean satisfiability problem (SAT) solvable in polinomial time implies
N=NP.

**NP**:
Class of computational problems for which a given solution can be verified
as a solution in polynomial time by a deterministic Turing machine.

In a letter addressed to von Neumann from 1956, see,
Godel attempted to describe the apparent difference between intuition and
systematic problem solving. His ideas, and those of others at the time,
evolved to become the complexity classes NP (modeling intuition, or 
theorem proving) and P (modeling problems that could be solved systematically
in a reasonable amount of time, like proof checking). Determining if these two
classes are indeed distinct has been considered a central question in 
theoretical computer science since the 1970s. It is now also considered a central
question in mathematics.

Kolmogorov Complexity

## Boolean satisfiability problem (SAT)

In computer science, the Boolean Satisfiability Problem (sometimes called
Propositional Satisfiability Problem and abbreviated as SATISFIABILITY or SAT)
is the problem of determining if there exists an interpretation that satisfies
a given Boolean formula. In other words, it asks whether the variables of a
given Boolean formula can be consistently replaced by the values TRUE or FALSE
in such a way that the formula evaluates to TRUE. If this is the case, the
formula is called satisfiable. On the other hand, if no such assignment exists,
the function expressed by the formula is identically FALSE for all possible
variable assignments and the formula is unsatisfiable. For example, the formula
"a AND NOT b" is satisfiable because one can find the values a = TRUE and b =
FALSE, which make (a AND NOT b) = TRUE. In contrast, "a AND NOT a" is
unsatisfiable.

# Type Theory

Type theory can be used as a foundation for mathematics, and indeed, it was
presented as such by Russell in his 1908 paper, which appeared the same year as
Zermelo's paper, presenting set theory as a foundation for mathematics.

## Homotopy Type Theory

Martin-Löf 1973 introduced a new basic type Id~A~(a,b), if a and b
are in the type A, which can be thought as the type
of equality proofs of the element a and b. 
intuitively, there seems to be at most an equality proof between two
elements a and b. Surprisingly, Hofmann and Streicher 1996 designed a model
of dependent type theory where this is not valid, that is a
model where they can be different proofs that two elements are equal.
In this model, a type is interpreted by a groupoid and the
type Id~A~(a,b) by the set of isomorphisms between a and b, set
which may have more than one element. The existence of this model
has the consequence that it cannot be proved in general in type
theory that an equality type has at most one element. This groupoid
interpretation has been generalized in the following way, which gives an intuitive
interpretation of the identity type. A type is interpreted by a topological
space, up to homotopy, and a type Id~A~(a,b) is interpreted by the type of paths connecting a and b.

Whereas in the usual approach
to the foundations of mathematics one takes sets as the basic entities from which
mathematical structures are constructed, in homotopy type theory the basic en-
tities are spaces (homotopy types), in the sense of homotopy theory, rather than
sets.

This approach is justified by the homotopy theoretic interpretation of type
theory, which was independently discovered by Awodey and Warren and Voevodsky,
building on ideas of Hofmann and Streicher, Moerdijk, Palmgren, and others.
This interpretation relates structures arising in homotopy theory, such as Kan
complexes and Quillen model categories, with Martin-Löf’s dependent type
theory.  At around the same time, Gambino and Garner, van den Berg and Garner,
and Lumsdaine showed that this interpretation could be turned around to
construct homotopy theoretic structures from the syntax of type theory. Crucial
to this entire endeavor was Voevodsky’s discovery of the Univalence Axiom which
captures important features of his Kan complex model of type theory.

The form of type theory with which homotopy type theory is concerned is some-
times called dependent type theory.

# IEEE 754-2008

To conform to the current standard, an implementation must implement at least
one of the basic formats as both an arithmetic format and an interchange format.

Every floating point number is unique. Zero is a special case because of this.
Every floating point number has an opposite.

## Format

Finite numbers, which may be either base 2 (binary) or base 10
(decimal). Each finite number is described by three integers: $s$ = a
sign (zero or one), $c$ = a significand (or 'coefficient'), $q$ = an exponent. 

$$(−1)^s × c × b^q$$

Two infinities: +∞ and −∞.

Two kinds of NaN: a quiet NaN (qNaN) and a signaling NaN (sNaN). 

$c$ must be an integer in the range zero through bp−1 (e.g., if b=10 and p=7
then c is 0 through 9999999)

$q$ must be an integer such that 1−emax ≤ q+p−1 ≤ emax (e.g., if p=7 and
emax=96 then q is −101 through 90).

Hence (for the example parameters) the smallest non-zero positive number that
can be represented is $1×10^{−101}$ and the largest is $9999999×10^{90}$
($9.999999×10^{96}$), and the full range of numbers is $−9.999999×10^{96}$
through $9.999999×10^{96}$. The numbers −b1−emax and b1−emax (here,
$−1×10^{−95}$ and $1×10^{−95}$) are the smallest (in magnitude) normal numbers;
non-zero numbers between these smallest numbers are called subnormal numbers.

$$x = -1^s \times 2^e \times 1.\text{mantissa}$$

The exponent is shift-127 encoded.

32-bit: 1 sign bit + 8 exponent bits + 23 mantissa bits
64-bit: 1 sign bit + 12 exponent bist " 52 mantissa bits

Devide-by-zero
signed zero

Epsilon:
The difference between 1.0 and the next available floating point number.
`std::numeric_limits<T>::epsilon`

Denormalized Numbers.
Good precision between -1 and 1.

`std::nextafter`

Units in last place (ulps).

Rounding:
Towards the nearest
Towards Zero
Towards positive infinity (round up)
Towards negative infinity (round down)
Round up vs. round even.
Correct rounding

Guard bit, round bit, sticky bit.

Stable algorithms.

# Gödels Incompleteness Proof

Now Gödel's first incompleteness theorem states that for any sufficiently strong,
consistent formal theory S there is a sentence GS which is
true but not derivable in S. 

Gödel announced the second incompleteness theorem in an abstract published in October
1930: no consistency proof of systems such as Principia, Zermelo-Fraenkel set theory,
or the systems investigated by Ackermann and von Neumann is possible by
methods which can be formulated in these systems. 

# Type systems

Simply typed lambda calculus: Functions form terms to terms.

System F  
Lamda calculus with polmorphism. Functions from types to terms.

System $\lambda\omega$: type operator: function from types to types

System LF: dependend types: functions from  terms to types.

# Combinators

I = λX.X  
K = λX.λY.X  
S = λX.λY.λZ.X(Z)(Y(Z))

# Informatik

**Types** are universal quantification about what can be done with data.

## Value

property:
1. if $a$ and $b$ have the same value, and
2. the same operation is applied to each object, then
3. (absent any exceptions or undefined behavior)
4. both object will again have the same value.

# Algorithms

1.    clearly specify the problem
1.    try to avoid doing any work
1.    design the interface
     1.    funtion's name
     1.    arguments
     1.    return type
     1.    interface contracts
     1.    concepts
1.    write the tests
1.    write the algorithm
1.    (optimize, profile)

Illset (the rules are unclear) and wellset (ep. games) problems.

Problem solving is a search problem.

Sometimes the only way to solve a problem is doing something random.

Sentence recognition is called *syntax analysis*.
For the recognition of regular sentences a finite automata, also
called a state machine, is necessary and sufficient.
If the resuling state is unique, the state machine is deterministic,
otherwise nondeterministic.

frontend:
charstream --lexing--> token stream --parsing-->
representation of the syntactic structure of the source text (<- type checking)
--> AST (in storage)

--code generation--> backend: sequence of instructions from the instruction set
of the target computer.

Process & input element & Algorithm & Syntax \\
lexical analysis & Character & Scanner & Regular \\
syntax analysis & symbol & Parser & Context free

A = A "a" | "b" is replaced by A = "b" {"a"}

# ---

data structures:

list
unordered set
sorted set

# binary heap

It’s a complete tree, which means it has the smallest possible height A heap or
a binary heap is a complete binary tree with some additional properties, known
as heap properties.  The Heap differs from a Binary Search Tree. The BST is an
ordered data structure, however, the Heap is not.  The heap can be either
Min-Heap or Max-Heap.  The main rule of the Max-Heap is that the subtree under
each node contains values less or equal than its root node. Whereas, it’s vice
versa for the Min-Heap.

# ---

An operand is an entity on which an operator acts.

Big-Endian "big end first"

# data-structures

(FIFO) Queue
priority Queue
LIFO Queue / Stack
Deque
Trie

